<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>EXPLORADOR ESPACIAL</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #efd1b5;
            color: #61443e;
            margin: 0;
            overflow: hidden;
        }
        a { color: #a06851; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">Plannet Fishers</a> - EXPLORADOR ESPACIAL <br>
        (left click: AVANZAR, right click: RETROCEDER)
    </div>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
            // Cambiar Stats y FirstPersonControls a URLs
    import Stats from 'https://unpkg.com/three@0.158.0/examples/jsm/libs/stats.module.js';
    import { FirstPersonControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/FirstPersonControls.js';
    
    // ImprovedNoise.js a menudo puede quedarse como local o ser cargado también:
    import { ImprovedNoise } from 'https://unpkg.com/three@0.158.0/examples/jsm/math/ImprovedNoise.js';

        let container, stats;
        let camera, controls, scene, renderer;
        let mesh, texture;
        const worldWidth = 256, worldDepth = 256;
        const clock = new THREE.Clock();

        init();

        function randomPastelColor() {
        const hue = Math.random() * 360;  // tono aleatorio
        const saturation = 40 + Math.random() * 30; // saturación moderada
        const lightness = 60 + Math.random() * 20;  // luminosidad
        const color = new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
        return color;
        }

        function init() {
            container = document.getElementById('container');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            scene = new THREE.Scene();
            // Asignar color aleatorio al fondo y la niebla
            const terrainColor = randomPastelColor();
            scene.background = terrainColor;
            const fogDensity = 0.0015 + trueRandom() * (0.0025 - 0.0005);
            scene.fog = new THREE.FogExp2(terrainColor, fogDensity);

            const data = generateHeight(worldWidth, worldDepth);

            function trueRandom() {
            const array = new Uint32Array(1);
            crypto.getRandomValues(array);
            return array[0] / 0xFFFFFFFF;
            }

            // Posición inicial aleatoria dentro del rango del terreno
            const startX = (trueRandom() - 0.5) * 700; // rango aprox. -3500 a 3500
            const startZ = (trueRandom() - 0.5) * 700;
            const startY = 800 + Math.random() * 200;   // altura variable

            camera.position.set(startX, startY, startZ);

            // Hacer que mire hacia el centro del mapa
            camera.lookAt(0, 300, 0);

            const geometry = new THREE.PlaneGeometry(7500, 7500, worldWidth - 1, worldDepth - 1);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
                vertices[j + 1] = data[i] * 10;
            }

            texture = new THREE.CanvasTexture(generateTexture(data, worldWidth, worldDepth));
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.colorSpace = THREE.SRGBColorSpace;

            mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshBasicMaterial({
                map: texture,
                color: terrainColor
            })
            );
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            controls = new FirstPersonControls(camera, renderer.domElement);
            controls.movementSpeed = 150;
            controls.lookSpeed = 0.1;

            stats = new Stats();
            container.appendChild(stats.dom);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls.handleResize();
        }

        function generateHeight(width, height) {
            let seed = Math.PI / 4;
            window.Math.random = function () {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };

            const size = width * height, data = new Uint8Array(size);
            const perlin = new ImprovedNoise(), z = Math.random() * 100;

            let quality = 1;
            for (let j = 0; j < 4; j++) {
                for (let i = 0; i < size; i++) {
                    const x = i % width, y = ~~(i / width);
                    data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
                }
                quality *= 5;
            }
            return data;
        }

        function generateTexture(data, width, height) {
            const vector3 = new THREE.Vector3(0, 0, 0);
            const sun = new THREE.Vector3(1, 1, 1).normalize();

            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const context = canvas.getContext('2d');
            context.fillStyle = '#000';
            context.fillRect(0, 0, width, height);

            const image = context.getImageData(0, 0, width, height);
            const imageData = image.data;

            for (let i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
                vector3.x = data[j - 2] - data[j + 2];
                vector3.y = 2;
                vector3.z = data[j - width * 2] - data[j + width * 2];
                vector3.normalize();
                const shade = vector3.dot(sun);

                imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
                imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
                imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
            }

            context.putImageData(image, 0, 0);

            // Scale 4x
            const canvasScaled = document.createElement('canvas');
            canvasScaled.width = width * 4; canvasScaled.height = height * 4;
            const ctx = canvasScaled.getContext('2d');
            ctx.scale(4, 4);
            ctx.drawImage(canvas, 0, 0);
            return canvasScaled;
        }

        function animate() {
            render();
            stats.update();
        }

        function render() {
            controls.update(clock.getDelta());
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
